# PlayLeetCode
LeetCode Training based on c++
Backtracking-Recursion

## Tips: 
* Click the ***`Number`***( # ) to the Questions
* Click the ***`Solution`***([00xx-Solution]) to the Solutions

| # |  Title  |  Difficulty  |  Method  | _Solution_
|:-:|:-:|:-:|:-:|:-:|
|[0062] | Unique-Paths                                                          | Medium    | DP          |[0062-Solution]|
|[0063] | Unique-Paths-II                                                       | Medium    | DP          |[0063-Solution]|
|[0064] | Minimum-Path-Sum                                                      | Medium    | DP          |[0064-Solution]|
|[0070] | Climbing-Stairs                                                       | Easy      | DP          |[0070-Solution]|
|[0091] | Decode-Ways                                                           | Medium    | DP          |[0091-Solution]|
|[0120] | Triangle                                                              | Medium    | DP          |[0120-Solution]|
|[0121] | Best-Time-to-Buy-and-Sell-Stock                                       | Easy      | DP          |[0121-Solution]|
|[0122] | Best-Time-to-Buy-and-Sell-Stock-II                                    | Easy      | DP          |[0122-Solution]|
|[0123] | Best-Time-to-Buy-and-Sell-Stock-III                                   | Hard      | DP          |[0123-Solution]|
|[0139] | Word-Break                                                            | Medium    | DP          |[0139-Solution]|
|[0188] | Best-Time-to-Buy-and-Sell-Stock-IV                                    | Hard      | DP          |[0188-Solution]|
|[0198] | House-Robber                                                          | Easy      | DP          |[0198-Solution]|
|[0213] | House-Robber-II                                                       | Medium    | DP          |[0213-Solution]|
|[0279] | Perfect-Squares                                                       | Medium    | DP          |[0279-Solution]|
|[0300] | Longest-Increasing-Subsequence                                        | Medium    | DP          |[0300-Solution]|
|[0309] | Best-Time-to-Buy-and-Sell-Stock-with-Cooldown                         | Medium    | DP          |[0309-Solution]|
|[0322] | Coin-Change                                                           | Medium    | DP          |[0322-Solution]|
|[0343] | Integer-Break                                                         | Medium    | DP          |[0343-Solution]|
|[0376] | Wiggle-Subsequence                                                    | Medium    | DP          |[0376-Solution]|
|[0377] | Combination-Sum-IV                                                    | Medium    | DFS         |[0377-Solution]|
|[0416] | Partition-Equal-Subset-Sum                                            | Medium    | DP          |[0416-Solution]|
|[0474] | Ones-and-Zeroes                                                       | Medium    | DP          |[0474-Solution]|
|[0494] | Target-Sum                                                            | Medium    | DP          |[0494-Solution]|
|[0714] | Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee                  | Medium    | DP          |[0714-Solution]|


[0062]: https://leetcode.com/problems/unique-paths/
[0063]: https://leetcode.com/problems/unique-paths-ii/
[0064]: https://leetcode.com/problems/minimum-path-sum/
[0070]: https://leetcode.com/problems/climbing-stairs/
[0091]: https://leetcode.com/problems/decode-ways/
[0120]: https://leetcode.com/problems/triangle/
[0121]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock/
[0122]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/
[0123]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/
[0139]: https://leetcode.com/problems/word-break/
[0188]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/
[0198]: https://leetcode.com/problems/house-robber/
[0213]: https://leetcode.com/problems/house-robber-ii/
[0279]: https://leetcode.com/problems/perfect-squares/
[0300]: https://leetcode.com/problems/longest-increasing-subsequence/
[0309]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/
[0322]: https://leetcode.com/problems/coin-change/
[0343]: https://leetcode.com/problems/integer-break/
[0376]: https://leetcode.com/problems/wiggle-subsequence/
[0377]: https://leetcode.com/problems/combination-sum-iv/    
[0416]: https://leetcode.com/problems/partition-equal-subset-sum/
[0474]: https://leetcode.com/problems/ones-and-zeroes/
[0494]: https://leetcode.com/problems/target-sum/
[0714]: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

[0062-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0062-Unique-Paths/main.cpp
[0063-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0063-Unique-Paths-II/main.cpp
[0064-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0064-Minimum-Path-Sum/main.cpp
[0070-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0070-Climbing-Stairs
[0091-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0091-Decode-Ways
[0120-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0120-Triangle/main.cpp
[0121-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0121-Best-Time-to-Buy-and-Sell-Stock/main.cpp
[0122-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0122-Best-Time-to-Buy-and-Sell-Stock-II/main.cpp
[0123-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0123-Best-Time-to-Buy-and-Sell-Stock-III/main.cpp
[0139-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0139-Word-Break
[0188-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0188-Best-Time-to-Buy-and-Sell-Stock-IV/main.cpp
[0198-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0198-House-Robber
[0213-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0213-House-Robber-II/main.cpp
[0279-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0279-Perfect-Squares
[0300-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0300-Longest-Increasing-Subsequence/DP-36ms.cpp
[0309-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/main.cpp
[0322-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0322-Coin-Change/DP.cpp
[0343-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0343-Integer-Break
[0376-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0376-Wiggle-Subsequence
[0377-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0377-Combination-Sum-IV  
[0416-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0416-Partition-Equal-Subset-Sum
[0474-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0474-Ones-and-Zeroes
[0494-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/tree/master/DynamicProgramming/0494-Target-Sum
[0714-Solution]: https://github.com/FeiZhao0531/PlayLeetCode/blob/master/DynamicProgramming/0714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/main.cpp


# 背包问题题目总结
动态规划常用来解决 **`最优化问题`** ，关键在于确定 **最优子结构** 并优先求解 **重叠子问题**。
属于用空间换取时间的一种高效算法，通常可以将指数级别的时间复杂度压缩到多项式级别。
常用的方法有：`自顶向下的记忆化搜索`， `自底向上的状态转移` [*(参考六道股票题的总结)*](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-wen/)。
在不能直接想出自底向上的方法时，优先使用自顶向下的递归方法，通常在画出递归树之后能清楚地看出状态转移的公式。

背包问题(Knapsack problem)是动态规划的一个经典问题，属于一种组合优化的NP完全问题。
问题可以描述为：给定一组物品(` 编号 0 ~ n-1 `)，每种物品都有自己的重量` w[i] `和价格`v[i] `，在限定的总重量( `总重量的限制 C ` )内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。[[1]](https://baike.baidu.com/item/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2416931?fr=aladdin)

--------------------------

## LeetCode上和背包问题相关的题目有：
*  [322]. [Coin Change](https://leetcode.com/problems/coin-change/)
*  [377]. [Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)
*  [416]. [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
*  [474]. [Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)
*  [139]. [Word Break](https://leetcode.com/problems/word-break/)
*  [494]. [Target Sum](https://leetcode.com/problems/target-sum/)

## 对各个题目分析
### 322. Coin Change
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。
```
示例：
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
```
分析：背包问题给定的一组物品即题目中的 coins，重量` w[i] `即为硬币的面值，价格`v[i]`全等于1。
不同于经典的背包问题，该题目需要达到确定的总金额 amount并且求出背包里物品的总价值的最小值(此处即是使用硬币的个数)，并且物品的使用次数不限，属于无限物品问题。
最后返回使用硬币的个数，若不能完全装满背包，则返回-1。

### 377. Combination Sum IV
给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。
```
示例：
nums = [1, 2, 3]
target = 4

所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
```
分析：背包问题给定的一组物品即题目中的 nums，重量` w[i] `即为 nums[i]，`总重量的限制 C` = target。
和322题一样，377题需要达到确定的target同时输出所有的组合排列，也是无限物品问题。
本质上和322题基本一致，但是不同的取用物品顺序也是不同的排列方式。

### 416. Partition Equal Subset Sum
给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
```
示例：
输入: [1, 5, 11, 5]
输出: true
解释: 数组可以分割成 [1, 5, 5] 和 [11].
```
分析：背包问题给定的一组物品即题目中的数组 nums，重量` w[i] `即为数组元素 nums[i]。
和322，377题一样，416题需要达到确定的总和( nums[i]求和的一半 )而不需要考虑背包里物品的总价值，返回是否能达到该`总重量的限制 C `即可。

### 474. Ones and Zeroes
使用给定的 m 个 0 和 n 个 1 ，找到一个仅包含 0 和 1 字符串的数组能拼出的字符串的最大数量。每个 0 和 1 至多被使用一次。
```
示例：
输入: string strs = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4
解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
```
分析：背包问题给定的一组物品即题目中的字符串数组 strs。和经典的背包问题不同，不仅需要考虑重量` w[i] `的限制，也需要考虑体积的限制，在本题目中即分别为字符串的‘0’，‘1’的个数限制。
474题需要重量和体积的双重限制下达到最大的价值(符合要求的字符串的个数)。

### 139. Word Break
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
说明：
* 拆分时可以重复使用字典中的单词。
* 你可以假设字典中没有重复的单词。

```
示例 1：
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
```
分析：背包问题给定的一组物品即题目中的字符串数组 wordDict, 背包为字符串s，从物品中不限次数挑选来填充字符串，和416题有些类似。

### 494. Target Sum
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。
```
示例：
输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
```
```
注意:

    数组的长度不会超过20，并且数组中的值全为正数。
    初始的数组的和不会超过1000。
    保证返回的最终结果为32位整数。

```

分析：第一反应是用回溯法来解决这个问题，递归遍历所有的可能组合，检查最后是否等于给定的要求的目标数S。
在递归求解的过程中可能会有很多的重复子问题，因此自然想到加上记忆化搜索来减小计算量。

首先，记忆化搜索的实现可以用```TreeMap-map<pair<int,int>, int>```，其中涉及到的3个量分别表示使用的nums数组中的前几个数、通过+ -组合求出的和、到当前的方法数，这种方法的使适用性最广，而且进一步可以将所有的组合具体形式求出。
另一方面，由于问题明确给出了数据规模，我们可以用```vector<vector<int>> memo```来代替TreeMap以获得更优的时间复杂度。memo[i][j]表示的意义即为当使用了前i个nums的数，组成的和为j的可能的组合数量。需要指出的是，由于nums排列求和之后可能是负数，需要在使用memo时将数组索引统一加上1000。
